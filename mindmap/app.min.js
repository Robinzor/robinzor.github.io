const svg = document.getElementById('svg');
const addNodeBtn = document.getElementById('addNode');
const zoomInBtn = document.getElementById('zoomIn');
const zoomOutBtn = document.getElementById('zoomOut');
const saveBtn = document.getElementById('save');
const exportBtn = document.getElementById('export');
const importBtn = document.getElementById('importBtn');
const importFile = document.getElementById('importFile');
const searchInput = document.getElementById('search');
const suggestionsEl = document.getElementById('suggestions');
const editor = document.getElementById('editor');
const nodeStyleSelect = document.getElementById('nodeStyle');
const edgeStyleSelect = document.getElementById('edgeStyle');
const nodePaletteSelect = document.getElementById('nodePalette');
const saveStatusEl = document.getElementById('saveStatus');
const autoSaveToggle = document.getElementById('autoSaveToggle');
const clearStorageBtn = document.getElementById('clearStorage');
const customCursor = document.createElement('div');
customCursor.id = 'customCursor';
const ring = document.createElement('div');
ring.className = 'ring';
customCursor.appendChild(ring);
document.body.appendChild(customCursor);
let customCursorVisible = false;
function showCustomCursor(){ if(!customCursorVisible){ customCursor.classList.add('visible'); customCursorVisible = true; } }
function hideCustomCursor(){ if(customCursorVisible){ customCursor.classList.remove('visible'); customCursorVisible = false; } }
svg.addEventListener('pointermove',(ev)=>{ if(ev.pointerType === 'touch') return; const x = ev.clientX - 10; const y = ev.clientY - 10; customCursor.style.transform = `translate(${x}px, ${y}px) scale(1)`; showCustomCursor(); });
svg.addEventListener('pointerenter',(ev)=>{ if(ev.pointerType !== 'touch') showCustomCursor(); });
svg.addEventListener('pointerleave',(ev)=>{ hideCustomCursor(); });
svg.addEventListener('pointerdown',()=>{ customCursor.classList.add('active'); });
svg.addEventListener('pointerup',()=>{ customCursor.classList.remove('active'); });
window.addEventListener('mouseout',()=>{ hideCustomCursor(); });
document.addEventListener('pointermove',(ev)=>{ if(ev.pointerType === 'touch') return; const overSVG = !!document.elementFromPoint(ev.clientX, ev.clientY) && svg.contains(document.elementFromPoint(ev.clientX, ev.clientY)); if(overSVG || dragging){ const x = ev.clientX - 10; const y = ev.clientY - 10; customCursor.style.transform = `translate(${x}px, ${y}px) scale(1)`; showCustomCursor(); } });

let autosaveTimer = null;
let saveStatusTimer = null;
let autoSaveEnabled = true;
let rootSpawnCounter = 0;
function doSave(showStatus = true){ try{ localStorage.setItem('mindmap', JSON.stringify(state)); if(showStatus && saveStatusEl){ saveStatusEl.textContent = 'Saved'; saveStatusEl.classList.add('visible'); if(saveStatusTimer) clearTimeout(saveStatusTimer); saveStatusTimer = setTimeout(()=>{ if(saveStatusEl){ saveStatusEl.classList.remove('visible'); saveStatusEl.textContent = ''; } }, 1400); } }catch(e){ console.warn('Save failed', e); } }
function scheduleAutosave(delay = 800){ if(!autoSaveEnabled) return; if(autosaveTimer) clearTimeout(autosaveTimer); autosaveTimer = setTimeout(()=>{ doSave(true); autosaveTimer = null; }, delay); }

let state = { nodes: [], links: [], nodeShape: 'circle' };
state.edgeStyle = state.edgeStyle || 'straight';
state.nodePalette = state.nodePalette || 'default';
let view = { scale: 1, panX: 0, panY: 0 };
let dragging = null;
let dragOffset = {x:0,y:0};
let panActive = false;
let lastPointer = null;
let editingNode = null;
let editingOriginal = '';
let selectedNodeId = null;
let justDragged = false;
const pointers = new Map();
let pinchActive = false;
let pinchStartDistance = 0;
let pinchStartScale = 1;
let pinchMidClient = {x:0,y:0};
// Track nodes for which controls should remain visible (e.g., tapped on mobile)
const persistentControls = new Set();

const g = document.createElementNS('http://www.w3.org/2000/svg','g');
svg.appendChild(g);

function uid(){return Date.now().toString(36)+Math.random().toString(36).slice(2,8)}

function addNode(x=null,y=null,label='New node'){
  let spawnX = x; let spawnY = y;
  if(spawnX == null || spawnY == null){
    const rootNodes = state.nodes.filter(n => !state.links.some(l => l.to === n.id));
    if(rootNodes.length > 0){
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      rootNodes.forEach(n=>{ minX = Math.min(minX, n.x); maxX = Math.max(maxX, n.x); minY = Math.min(minY, n.y); maxY = Math.max(maxY, n.y); });
      const verticalSpacing = 90;
      const centerX = (minX + maxX) / 2;
      const desiredRow = Math.max(0, rootSpawnCounter);
      const candX = centerX;
      const candY = minY - (desiredRow + 1) * verticalSpacing;
      const minDist = 100;
      const isFree = (cx, cy) => !state.nodes.some(n => Math.hypot(n.x - cx, n.y - cy) < minDist);
      if(isFree(candX, candY)){ spawnX = candX; spawnY = candY; }
      else {
        const xOffsets = [ -80, 80, -160, 160, -240, 240 ]; let found = false;
        for(const xo of xOffsets){ if(isFree(candX + xo, candY)){ spawnX = candX + xo; spawnY = candY; found = true; break; } }
        if(!found){ const maxRadius = 800; const radiusStep = 80; for(let r=radiusStep; r<=maxRadius && !found; r+=radiusStep){ const steps = Math.max(8, Math.floor((2*Math.PI*r)/80)); for(let s=0;s<steps && !found;s++){ const angle = (s/steps)*2*Math.PI; const nx = candX + r*Math.cos(angle); const ny = candY + r*Math.sin(angle); if(isFree(nx, ny)) { spawnX = nx; spawnY = ny; found = true; break; } } } if(!found){ spawnX = candX; spawnY = candY; } }
      }
    } else { spawnX = 300; spawnY = 200; }
  }
  const id=uid();
  state.nodes.push({id,x: spawnX,y: spawnY,label});
  rootSpawnCounter = rootSpawnCounter + 1;
  selectedNodeId = id;
  render();
  const newNode = state.nodes.find(n => n.id === id);
  if(newNode) showEditor(newNode);
  try{
    const svgRect = svg.getBoundingClientRect();
    const padding = 120;
    const screenX = svgRect.left + view.panX + newNode.x * view.scale;
    const screenY = svgRect.top + view.panY + newNode.y * view.scale;
    const left = svgRect.left + padding; const top = svgRect.top + padding; const right = svgRect.right - padding; const bottom = svgRect.bottom - padding;
    if(screenX < left || screenX > right || screenY < top || screenY > bottom){ const targetPanX = (left - svgRect.left) - newNode.x * view.scale; const targetPanY = (top - svgRect.top) - newNode.y * view.scale; animatePan(view.panX, view.panY, targetPanX, targetPanY, 360); }
  }catch(e){}
  scheduleAutosave();
  return id;
}

function loadMapFromLocalStorage(){
  try{
    const raw = localStorage.getItem('mindmap');
    if(raw){
      const parsed = JSON.parse(raw);
      if(parsed && typeof parsed === 'object'){
        state = parsed;

        state.nodeShape = state.nodeShape || 'circle';
        state.edgeStyle = state.edgeStyle || 'straight';
        state.nodePalette = state.nodePalette || 'default';
        if(nodeStyleSelect) nodeStyleSelect.value = state.nodeShape;
        if(edgeStyleSelect) edgeStyleSelect.value = state.edgeStyle;
        if(nodePaletteSelect) nodePaletteSelect.value = state.nodePalette;

        rootSpawnCounter = state.nodes ? state.nodes.filter(n => !state.links.some(l => l.to === n.id)).length : 0;
        return true;
      }
    }
  }catch(e){ console.warn('Failed to load saved map', e); }
  return false;
}

function connect(a,b){ state.links.push({from:a,to:b}); render(); }

function clearG(){ while(g.firstChild) g.removeChild(g.firstChild) }

function render(){
  clearG();

  document.body.classList.remove('palette-default','palette-pastel','palette-monochrome','palette-vibrant');
  document.body.classList.add('palette-' + (state.nodePalette || 'default'));
  g.setAttribute('transform', `translate(${view.panX},${view.panY}) scale(${view.scale})`);
  state.links.forEach(l=>{
    const from = state.nodes.find(n=>n.id===l.from);
    const to = state.nodes.find(n=>n.id===l.to);
    if(!from||!to) return;
    const path = document.createElementNS('http://www.w3.org/2000/svg','path');
    const sel = state.edgeStyle || 'straight';
    let d = '';
       if(sel === 'elbow'){

         const estHalf = (node)=>{
           const lbl = (node && node.label) ? String(node.label) : '';
           const cw = 8;
           const w = Math.min(320, Math.max(110, lbl.length * cw + 40));
           return w/2;
         };
         const fromHalf = estHalf(from);
         const toHalf = estHalf(to);
         let midX;
         if(from.x <= to.x){

           midX = from.x + fromHalf + 12;
         } else {

           midX = to.x + toHalf + 12;
         }
         d = `M ${from.x} ${from.y} L ${midX} ${from.y} L ${midX} ${to.y} L ${to.x} ${to.y}`;
    } else {
      d = `M ${from.x} ${from.y} L ${to.x} ${to.y}`;
    }
    path.setAttribute('d', d);

    const edgeClass = ['edge'];
    if (sel === 'elbow') edgeClass.push('elbow');
    if (sel === 'dashed') edgeClass.push('dashed');
    path.setAttribute('class', edgeClass.join(' '));
    g.appendChild(path);
  });
  const q = searchInput.value.trim().toLowerCase();
  state.nodes.forEach(n=>{
    const group = document.createElementNS('http://www.w3.org/2000/svg','g');
    group.setAttribute('transform', `translate(${n.x},${n.y})`);
    group.dataset.id = n.id;
    group.classList.add('node-group');
    if(selectedNodeId === n.id) group.classList.add('selected');

    let shapeEl = null;
    let rectW = 0, rectH = 0;

    const wrapText = (text, maxWidthPx, charWidth = 8) => {
      if(!text) return [''];
      const words = text.split(/\s+/);
      const lines = [];
      let cur = '';
      for(const w of words){
        const test = cur ? (cur + ' ' + w) : w;
        if(test.length * charWidth <= maxWidthPx){ cur = test; }
        else { if(cur) lines.push(cur); cur = w; }
      }
      if(cur) lines.push(cur);
      return lines;
    };

    const fontSize = 14;
    const charWidth = 8;
    const lineHeight = 18;
    const label = String(n.label || '');
    if(state.nodeShape === 'box'){
      const maxW = 320 - 40;
      const lines = wrapText(label, maxW, charWidth);

      const longest = Math.max(...lines.map(l=>l.length), 0);
      rectW = Math.min(320, Math.max(110, longest * charWidth + 40));
      rectH = Math.max(48, lines.length * lineHeight + 20);
      const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
      rect.setAttribute('class','node-rect');
      rect.setAttribute('x', -rectW/2);
      rect.setAttribute('y', -rectH/2);
      rect.setAttribute('width', rectW);
      rect.setAttribute('height', rectH);
      rect.setAttribute('rx', 10);
      group.appendChild(rect);
      shapeEl = rect;
      const text = document.createElementNS('http://www.w3.org/2000/svg','text');
      text.setAttribute('class','node-text');
      text.setAttribute('text-anchor','middle');
      text.setAttribute('y','0');
      text.setAttribute('dominant-baseline','middle');

      lines.forEach((ln, idx)=>{
        const t = document.createElementNS('http://www.w3.org/2000/svg','tspan');
        t.setAttribute('x', '0');
        const dy = (idx === 0) ? -((lines.length - 1) * lineHeight) / 2 : lineHeight;
        t.setAttribute('dy', dy + '');
        t.textContent = ln;
        text.appendChild(t);
      });
      group.appendChild(text);
    } else {

      const maxDia = 320;
      const defaultR = 48;
      const maxInnerW = maxDia - 40;
      const lines = wrapText(label, maxInnerW, charWidth);
      const longest = Math.max(...lines.map(l=>l.length), 0);
      const neededW = Math.min(maxInnerW, longest * charWidth + 20);
      const r = Math.max(defaultR, Math.ceil(neededW / 2));
      const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');
      circ.setAttribute('r', r);
      circ.setAttribute('class','node-circle');
      group.appendChild(circ);
      shapeEl = circ;
      const text = document.createElementNS('http://www.w3.org/2000/svg','text');
      text.setAttribute('class','node-text');
      text.setAttribute('text-anchor','middle');
      text.setAttribute('y','0');
      text.setAttribute('dominant-baseline','middle');

      lines.forEach((ln, idx)=>{
        const t = document.createElementNS('http://www.w3.org/2000/svg','tspan');
        t.setAttribute('x', '0');
        const dy = (idx === 0) ? -((lines.length - 1) * lineHeight) / 2 : lineHeight;
        t.setAttribute('dy', dy + '');
        t.textContent = ln;
        text.appendChild(t);
      });
      group.appendChild(text);

      rectW = r * 2;
    }

    const controls = document.createElementNS('http://www.w3.org/2000/svg','g');
    controls.setAttribute('class','node-controls');

    // If this node was selected/persisted, keep controls visible and mark persistent
    if(persistentControls.has(n.id) || selectedNodeId === n.id){
      controls.setAttribute('visibility','visible');
      if(persistentControls.has(n.id)) controls.classList.add('persistent');
    } else {
      controls.setAttribute('visibility', 'hidden');
    }

    const ctrlStartX = state.nodeShape === 'box' ? Math.max(60, rectW/2 + 14) : 60;

    const editBg = document.createElementNS('http://www.w3.org/2000/svg','circle');
    editBg.setAttribute('class','control-bg control-btn');
    editBg.setAttribute('cx', ctrlStartX - 32);
    editBg.setAttribute('cy', -40);
    editBg.setAttribute('r', 12);
    controls.appendChild(editBg);
    const editText = document.createElementNS('http://www.w3.org/2000/svg','text');
    editText.setAttribute('class','control-text');
    editText.setAttribute('x', ctrlStartX - 32);
    editText.setAttribute('y', -40);
    editText.textContent = '\u270E';
    controls.appendChild(editText);
    const plusBg = document.createElementNS('http://www.w3.org/2000/svg','circle');
    plusBg.setAttribute('class','control-bg control-btn');
    plusBg.setAttribute('cx', ctrlStartX);
    plusBg.setAttribute('cy', -40);
    plusBg.setAttribute('r', 12);
    controls.appendChild(plusBg);
    const plusText = document.createElementNS('http://www.w3.org/2000/svg','text');
    plusText.setAttribute('class','control-text');
    plusText.setAttribute('x', ctrlStartX);
    plusText.setAttribute('y', -40);
    plusText.textContent = '+';
    controls.appendChild(plusText);

    [editBg, editText].forEach(el=>{
      el.addEventListener('pointerdown', ev=>{ ev.stopPropagation(); ev.preventDefault(); });

      el.addEventListener('mousedown', (ev)=>{ ev.stopPropagation(); ev.preventDefault(); showEditor(n); });
      el.addEventListener('click', (ev)=>{ ev.stopPropagation(); ev.preventDefault(); showEditor(n); });
    });

    const minusBg = document.createElementNS('http://www.w3.org/2000/svg','circle');
    minusBg.setAttribute('class','control-bg control-btn');
    minusBg.setAttribute('cx', ctrlStartX + 28);
    minusBg.setAttribute('cy', -40);
    minusBg.setAttribute('r', 12);
    controls.appendChild(minusBg);
    const minusText = document.createElementNS('http://www.w3.org/2000/svg','text');
    minusText.setAttribute('class','control-text');
    minusText.setAttribute('x', ctrlStartX + 28);
    minusText.setAttribute('y', -40);
    minusText.textContent = '\u2212';
    controls.appendChild(minusText);

    [plusBg, plusText, minusBg, minusText].forEach(el=>{
      el.addEventListener('pointerdown', ev=>{ ev.stopPropagation(); ev.preventDefault(); if(hideTimeout){ clearTimeout(hideTimeout); hideTimeout = null; } showControls(); });
    });

    plusBg.addEventListener('click', (ev)=>{ ev.stopPropagation(); addChild(n); scheduleHide(); });
    plusText.addEventListener('click', (ev)=>{ ev.stopPropagation(); addChild(n); scheduleHide(); });
    minusBg.addEventListener('click', (ev)=>{ ev.stopPropagation(); removeNode(n.id); scheduleHide(); });
    minusText.addEventListener('click', (ev)=>{ ev.stopPropagation(); removeNode(n.id); scheduleHide(); });

    group.appendChild(controls);

    let hideTimeout = null;
    const showControls = ()=>{ if(hideTimeout){ clearTimeout(hideTimeout); hideTimeout = null; } controls.setAttribute('visibility','visible'); };
    const scheduleHide = (delay = 1500)=>{ if(hideTimeout) clearTimeout(hideTimeout); hideTimeout = setTimeout(()=>{ controls.setAttribute('visibility','hidden'); hideTimeout = null; }, delay); };

    group.addEventListener('pointerenter', ()=>{
      if(persistentControls.has(n.id)){ controls.classList.remove('faded'); }
      else { showControls(); }
    });
    group.addEventListener('pointerleave', ()=>{
      if(persistentControls.has(n.id)){ controls.classList.add('faded'); }
      else { scheduleHide(); }
    });

    controls.addEventListener('pointerenter', ()=>{
      if(persistentControls.has(n.id)){ controls.classList.remove('faded'); }
      else { showControls(); }
    });
    controls.addEventListener('pointerleave', ()=>{
      if(persistentControls.has(n.id)){ controls.classList.add('faded'); }
      else { scheduleHide(); }
    });

    group.addEventListener('click', (ev)=>{
      ev.stopPropagation();
      if(justDragged){

        justDragged = false;
        return;
      }
      selectedNodeId = n.id;
      // Mark controls persistent so they stay visible after tap on mobile
      persistentControls.add(n.id);

      // Do not open the inline editor on click/double-click; editing is via the pencil control only
      render();
    });

    if(q && n.label.toLowerCase().includes(q)) {
      if(shapeEl) shapeEl.classList.add('match');
    } else {
      if(shapeEl) shapeEl.classList.remove('match');
    }

    group.addEventListener('pointerdown', (ev)=>{
      ev.stopPropagation();
      if(ev.button===2) return;
      // On touch, briefly show the controls so buttons are reachable
      if(ev.pointerType === 'touch'){
        try{ showControls(); scheduleHide(); }catch(e){}
      }

      if(ev.detail && ev.detail > 1) return;
      dragging = n;
      svg.setPointerCapture(ev.pointerId);
      dragOffset.x = (ev.clientX - svg.getBoundingClientRect().left - view.panX)/view.scale - n.x;
      dragOffset.y = (ev.clientY - svg.getBoundingClientRect().top - view.panY)/view.scale - n.y;
    });
    group.addEventListener('dblclick', (ev)=>{
      ev.stopPropagation();

      showEditor(n);
    });

    g.appendChild(group);
  });
}

function addChild(parentNode){
  if(!parentNode) { console.warn('[mindmap] addChild called without parentNode'); return; }
  const id = uid();
  console.log('[mindmap] addChild ->', {parentId: parentNode.id, id});

  const initialX = parentNode.x + 140;
  state.nodes.push({id, x: initialX, y: parentNode.y, label: 'New'});
  state.links.push({from: parentNode.id, to: id});

  const childLinks = state.links.filter(l => l.from === parentNode.id);
  const childIds = childLinks.map(l => l.to);
  const children = childIds.map(cid => state.nodes.find(n => n.id === cid)).filter(Boolean);
  const spacing = 90;
  const total = children.length;

  children.forEach((ch, idx)=>{
    const offset = (idx - (total - 1) / 2) * spacing;
    let targetX = parentNode.x + 140;
    let targetY = parentNode.y + offset;

    const minDist = 80;
    const isFreePos = (cx, cy, ignoreId) => !state.nodes.some(n => n.id !== ignoreId && !childIds.includes(n.id) && Math.hypot(n.x - cx, n.y - cy) < minDist);
    let placed = false;

    for(let step = 0; step < 6 && !placed; step++){
      const tryX = targetX + step * 40;
      if(isFreePos(tryX, targetY, ch.id)){
        ch.x = tryX; ch.y = targetY; placed = true; break;
      }
    }
    if(!placed){ ch.x = targetX; ch.y = targetY; }
  });

  selectedNodeId = id;
  render();
  const newNode = state.nodes.find(n => n.id === id);
  if(newNode) showEditor(newNode);

  scheduleAutosave();
}

function removeNode(id){

  state.nodes = state.nodes.filter(n => n.id !== id);

  state.links = state.links.filter(l => l.from !== id && l.to !== id);

  if(editingNode && editingNode.id === id){ hideEditor(false); }
  // remove any persistent control state for this node
  if(persistentControls.has(id)) persistentControls.delete(id);
  render();

  scheduleAutosave();
}

svg.addEventListener('pointermove', (ev)=>{

  if(pointers.has(ev.pointerId)) pointers.set(ev.pointerId, ev);

  if(pinchActive && pointers.size === 2){

    const ps = Array.from(pointers.values());
    const dx = ps[0].clientX - ps[1].clientX;
    const dy = ps[0].clientY - ps[1].clientY;
    const dist = Math.hypot(dx, dy);
    if(pinchStartDistance > 0){
      const newScale = Math.max(0.1, Math.min(4, pinchStartScale * (dist / pinchStartDistance)));

      const svgRect = svg.getBoundingClientRect();
      const midClientX = pinchMidClient.x;
      const midClientY = pinchMidClient.y;

      const svgX = (midClientX - svgRect.left - view.panX) / view.scale;
      const svgY = (midClientY - svgRect.top - view.panY) / view.scale;

      view.scale = newScale;
      view.panX = midClientX - svgRect.left - svgX * view.scale;
      view.panY = midClientY - svgRect.top - svgY * view.scale;
      render();
    }
    return;
  }
  if(dragging){
    const rect = svg.getBoundingClientRect();
    const x = (ev.clientX - rect.left - view.panX)/view.scale - dragOffset.x;
    const y = (ev.clientY - rect.top - view.panY)/view.scale - dragOffset.y;
    dragging.x = x; dragging.y = y;
    render();
  } else if(panActive && lastPointer){
    const dx = ev.clientX - lastPointer.x;
    const dy = ev.clientY - lastPointer.y;
    view.panX += dx; view.panY += dy;
    lastPointer = {x:ev.clientX, y:ev.clientY};
    render();
  }
});

svg.addEventListener('pointerup', (ev)=>{

  if(pointers.has(ev.pointerId)) pointers.delete(ev.pointerId);

  if(pinchActive && pointers.size < 2) pinchActive = false;
  if(dragging){ svg.releasePointerCapture(ev.pointerId); dragging=null; justDragged = true; setTimeout(()=>{ justDragged = false; }, 200); scheduleAutosave(); }
  panActive = false;
  lastPointer = null;
});

svg.addEventListener('pointerdown', (ev)=>{

  pointers.set(ev.pointerId, ev);
  try{ svg.setPointerCapture(ev.pointerId); }catch(e){}
  if(ev.pointerType === 'touch') ev.preventDefault();

  if(pointers.size === 2){

    pinchActive = true;
    pinchStartScale = view.scale;
    const ps = Array.from(pointers.values());
    const dx = ps[0].clientX - ps[1].clientX;
    const dy = ps[0].clientY - ps[1].clientY;
    pinchStartDistance = Math.hypot(dx, dy);
    pinchMidClient = { x: (ps[0].clientX + ps[1].clientX)/2, y: (ps[0].clientY + ps[1].clientY)/2 };
  }

  if(ev.target === svg && !pinchActive){
    panActive = true;
    lastPointer = {x:ev.clientX, y:ev.clientY};
    // clicking background clears selection and persistent controls
    selectedNodeId = null;
    persistentControls.clear();
    render();
  }
});

svg.addEventListener('pointercancel', (ev)=>{ if(pointers.has(ev.pointerId)) pointers.delete(ev.pointerId); pinchActive = false; });

addNodeBtn.addEventListener('click', ()=>{ addNode(undefined, undefined, 'Idea'); });

svg.addEventListener('wheel', (ev)=>{

  ev.preventDefault();

  if(pinchActive || dragging) return;

  const rect = svg.getBoundingClientRect();

  if(ev.ctrlKey || ev.metaKey){
    const delta = ev.deltaY;

    const factor = Math.pow(1.08, -Math.sign(delta) * Math.min(6, Math.abs(delta)/100));
    const mouseSvgX = (ev.clientX - rect.left - view.panX) / view.scale;
    const mouseSvgY = (ev.clientY - rect.top - view.panY) / view.scale;
    const newScale = Math.max(0.1, Math.min(4, view.scale * factor));

    view.panX = ev.clientX - rect.left - mouseSvgX * newScale;
    view.panY = ev.clientY - rect.top - mouseSvgY * newScale;
    view.scale = newScale;
    render();
    return;
  }

  const panSpeed = 1.0;
  view.panX -= ev.deltaX * panSpeed;
  view.panY -= ev.deltaY * panSpeed;
  render();
}, {passive:false});

zoomInBtn.addEventListener('click', ()=>{ view.scale = Math.min(3, view.scale * 1.2); render(); });
zoomOutBtn.addEventListener('click', ()=>{ view.scale = Math.max(0.4, view.scale / 1.2); render(); });

saveBtn.addEventListener('click', ()=>{
  doSave(true);
});

exportBtn.addEventListener('click', ()=>{
  const blob = new Blob([JSON.stringify(state, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'mindmap.json';
  a.click();
  URL.revokeObjectURL(url);
});

importBtn.addEventListener('click', ()=> importFile.click());
importFile.addEventListener('change', (ev)=>{
  const f = ev.target.files[0]; if(!f) return;
  const reader = new FileReader();
  reader.onload = e => { try{ state = JSON.parse(e.target.result); if(nodeStyleSelect) nodeStyleSelect.value = state.nodeShape || 'circle'; if(edgeStyleSelect) edgeStyleSelect.value = state.edgeStyle || 'straight'; if(nodePaletteSelect) nodePaletteSelect.value = state.nodePalette || 'default'; render(); }catch(err){ alert('Invalid JSON') } };
  reader.readAsText(f);
  importFile.value = '';
});

searchInput.addEventListener('input', ()=> render());

let suggestionResults = [];
let suggestionIndex = -1;

function renderSuggestions(q){
  suggestionResults = [];
  suggestionIndex = -1;
  suggestionsEl.innerHTML = '';
  const term = (q||'').trim().toLowerCase();
  if(!term) { suggestionsEl.classList.remove('visible'); return; }

  for(const n of state.nodes){
    if(!n.label) continue;
    const label = n.label.toString();
    const ll = label.toLowerCase();
    if(ll.includes(term)){
      suggestionResults.push({id: n.id, label, x: n.x, y: n.y});
    }
    if(suggestionResults.length >= 16) break;
  }
  if(suggestionResults.length === 0){ suggestionsEl.classList.remove('visible'); return; }

  suggestionResults.forEach((s, i)=>{
    const div = document.createElement('div');
    div.className = 'suggestion';
    div.dataset.index = i;
    const span = document.createElement('span');
    span.className = 'label';
    span.textContent = s.label;
    div.appendChild(span);
    const meta = document.createElement('span'); meta.className = 'meta';

    meta.textContent = (s.x !== undefined && s.y !== undefined) ? `${Math.round(s.x)},${Math.round(s.y)}` : 'node';
    div.appendChild(meta);
    div.addEventListener('mousedown', (ev)=>{

      ev.preventDefault();
      selectSuggestion(i);
    });
    suggestionsEl.appendChild(div);
  });
  suggestionsEl.classList.add('visible');
}

function highlightSuggestion(i){
  suggestionIndex = i;
  const items = suggestionsEl.querySelectorAll('.suggestion');
  items.forEach((it, idx)=>{
    it.classList.toggle('active', idx === i);
    if(idx === i) it.scrollIntoView({block:'nearest'});
  });
}

function selectSuggestion(i){
  const s = suggestionResults[i];
  if(!s) return;
  searchInput.value = s.label;
  suggestionsEl.classList.remove('visible');

  const node = state.nodes.find(n=>n.id === s.id) || state.nodes.find(n=>n.label === s.label);
  if(node) focusNode(node);
}

searchInput.addEventListener('input', (ev)=>{
  render();
  renderSuggestions(searchInput.value);
});

searchInput.addEventListener('keydown', (ev)=>{
  if(suggestionsEl.classList.contains('visible')){
    if(ev.key === 'ArrowDown'){
      ev.preventDefault();
      const next = Math.min(suggestionResults.length - 1, suggestionIndex + 1 < 0 ? 0 : suggestionIndex + 1);
      highlightSuggestion(next);
      return;
    } else if(ev.key === 'ArrowUp'){
      ev.preventDefault();
      const prev = Math.max(0, suggestionIndex - 1);
      highlightSuggestion(prev);
      return;
    } else if(ev.key === 'Enter'){
      if(suggestionIndex >= 0){
        ev.preventDefault();
        selectSuggestion(suggestionIndex);
        return;
      }

    } else if(ev.key === 'Escape'){
      suggestionsEl.classList.remove('visible');
    }

      scheduleAutosave();
  }
});

searchInput.addEventListener('blur', ()=>{ setTimeout(()=>{ suggestionsEl.classList.remove('visible'); }, 180); });

function animatePan(fromX, fromY, toX, toY, duration = 300){
  const start = performance.now();
  function step(ts){
    const t = Math.min(1, (ts - start) / duration);

    const eased = t < 0.5 ? 2*t*t : -1 + (4 - 2*t)*t;
    view.panX = fromX + (toX - fromX) * eased;
    view.panY = fromY + (toY - fromY) * eased;
    render();
    if(t < 1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

function focusNode(node){
  if(!node) return;
  selectedNodeId = node.id;
  const svgRect = svg.getBoundingClientRect();

  const targetCX = svgRect.width / 2;
  const targetCY = svgRect.height / 2;

  const targetPanX = targetCX - node.x * view.scale;
  const targetPanY = targetCY - node.y * view.scale;

  animatePan(view.panX, view.panY, targetPanX, targetPanY, 320);
}

searchInput.addEventListener('keydown', (ev)=>{
  if(ev.key === 'Enter'){
    const q = searchInput.value.trim().toLowerCase();
    if(!q) return;
    const found = state.nodes.find(n => n.label && n.label.toLowerCase().includes(q));
    if(found){
      focusNode(found);
    } else {

      flashInputNotFound();
    }
    ev.preventDefault();
  }
});

function flashInputNotFound(){
  const el = searchInput;
  const prev = el.style.backgroundColor;
  el.style.transition = 'background-color 120ms';
  el.style.backgroundColor = 'rgba(255,80,80,0.12)';
  setTimeout(()=>{ el.style.backgroundColor = prev || 'transparent'; }, 300);
}

function showEditor(node){
  editingNode = node;
  editingOriginal = node.label;
  editor.textContent = node.label;
  editor.setAttribute('aria-hidden','false');
  positionEditor(node);
  editor.focus();

  document.getSelection().selectAllChildren(editor);
  document.getSelection().collapseToEnd();
}

function hideEditor(save){
  if(!editingNode) return;
  if(save){
    editingNode.label = editor.textContent.trim() || editingNode.label;
    render();

    try{ doSave(true); }catch(e){  }
  }
  editingNode = null;
  editingOriginal = '';
  editor.setAttribute('aria-hidden','true');
}

function positionEditor(node){
  const svgRect = svg.getBoundingClientRect();

  const screenX = svgRect.left + view.panX + node.x * view.scale;
  const screenY = svgRect.top + view.panY + node.y * view.scale;

  const w = Math.min(320, Math.max(140, (node.label||'').length * 8 + 40));
  editor.style.width = w + 'px';

  editor.style.left = (screenX - w/2) + 'px';
  editor.style.top = (screenY - 24) + 'px';
}

editor.addEventListener('keydown', (ev)=>{
  if(ev.key === 'Enter'){
    ev.preventDefault();
    hideEditor(true);
    editor.blur();
  } else if(ev.key === 'Escape'){
    ev.preventDefault();

    editor.textContent = editingOriginal;
    hideEditor(false);
    editor.blur();
  }
});

editor.addEventListener('blur', ()=>{

  hideEditor(true);
});

window.addEventListener('resize', ()=>{ if(editingNode) positionEditor(editingNode); });

function loadTheme(){
  document.body.classList.add('dark');
}

function loadAutoSavePref(){
  try{
    const raw = localStorage.getItem('mindmap-autosave');
    if(raw !== null){
      autoSaveEnabled = raw === '1';
    } else {
      autoSaveEnabled = true;
    }
    if(autoSaveToggle){ autoSaveToggle.checked = !!autoSaveEnabled; }
  }catch(e){ autoSaveEnabled = true; }
}

function saveAutoSavePref(){
  try{ localStorage.setItem('mindmap-autosave', autoSaveEnabled ? '1' : '0'); }catch(e){}
}

function clearLocalStorageForApp(){
  try{
    const keys = [];
    for(let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i);
      if(k && k.indexOf('mindmap') === 0) keys.push(k);
    }
    keys.forEach(k=> localStorage.removeItem(k));
  }catch(e){ console.warn('Failed clearing storage', e); }
}

loadTheme();

loadAutoSavePref();
if(autoSaveToggle){
  autoSaveToggle.addEventListener('change', ()=>{
    autoSaveEnabled = !!autoSaveToggle.checked;
    saveAutoSavePref();

    if(saveStatusEl){
      saveStatusEl.textContent = autoSaveEnabled ? 'Autosave on' : 'Autosave off';
      saveStatusEl.classList.add('visible');
      if(saveStatusTimer) clearTimeout(saveStatusTimer);
      saveStatusTimer = setTimeout(()=>{ saveStatusEl.classList.remove('visible'); saveStatusEl.textContent = ''; }, 1200);
    }

    if(autoSaveEnabled) scheduleAutosave(500);
    else if(autosaveTimer){ clearTimeout(autosaveTimer); autosaveTimer = null; }
  });
}

if(clearStorageBtn){
  clearStorageBtn.addEventListener('click', ()=>{
    const ok = confirm('Delete saved mindmap data from localStorage? This cannot be undone.');
    if(!ok) return;
    clearLocalStorageForApp();

    state = { nodes: [], links: [], nodeShape: 'circle', edgeStyle: 'straight', nodePalette: 'default' };
    rootSpawnCounter = 0;
    if(nodeStyleSelect) nodeStyleSelect.value = state.nodeShape || 'circle';
    if(edgeStyleSelect) edgeStyleSelect.value = state.edgeStyle || 'straight';
    if(nodePaletteSelect) nodePaletteSelect.value = state.nodePalette || 'default';
    render();

    if(saveStatusEl){ saveStatusEl.textContent = 'Saved data cleared'; saveStatusEl.classList.add('visible'); if(saveStatusTimer) clearTimeout(saveStatusTimer); saveStatusTimer = setTimeout(()=>{ saveStatusEl.classList.remove('visible'); saveStatusEl.textContent = ''; }, 1400); }
  });
}

if(nodeStyleSelect){
  nodeStyleSelect.value = state.nodeShape || 'circle';
  nodeStyleSelect.addEventListener('change', ()=>{
    state.nodeShape = nodeStyleSelect.value || 'circle';
    render();
  });
}

if(edgeStyleSelect){
  edgeStyleSelect.value = state.edgeStyle || 'straight';
  edgeStyleSelect.addEventListener('change', ()=>{
    state.edgeStyle = edgeStyleSelect.value || 'straight';
    render();
    scheduleAutosave(600);
  });
}

if(nodePaletteSelect){
  nodePaletteSelect.value = state.nodePalette || 'default';
  nodePaletteSelect.addEventListener('change', ()=>{
    state.nodePalette = nodePaletteSelect.value || 'default';
    render();
    scheduleAutosave(600);
  });
}

if(!loadMapFromLocalStorage()){
  // Start with an empty canvas when there's no saved map.
  // Do not seed default nodes â€” user starts from blank slate.
  state = state || { nodes: [], links: [], nodeShape: 'circle', edgeStyle: 'straight', nodePalette: 'default' };
  rootSpawnCounter = state.nodes.filter(n => !state.links.some(l => l.to === n.id)).length;
}
render();
